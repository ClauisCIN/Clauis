# Clauis
### 指针的 `const` 修饰

`const` 可以修饰数据类型，也可以修饰指针变量。

#### 常量指针（修饰数据类型）

`const` 修饰数据类型时，指针指向的地址可以改变，但指针指向的地址所对应的内容不可以改变。

```cpp
int a = 0, b = 0;
const int *p = &a;
*p = 1; // 错误
p = &b; // 正确
```

#### 指针常量（修饰指针变量）

`const` 修饰指针变量时，指针指向的地址不可以改变，但指针指向的地址所对应的内容可以改变。

```cpp
int a = 0, b = 0;
int *const p = &a;
*p = 1; // 正确
p = &b; // 错误
```
![](https://pic.imgdb.cn/item/676e9ed0d0e0a243d4ebc204.png)

### 指针运算：（指针在内存中的移位）

- 赋值运算
- 算术运算
- 比较运算（使指针变量指向某一对象）

####1. 赋值运算：

    ![](https://pic.imgdb.cn/item/676e9ed4d0e0a243d4ebc205.png)

1. 指针的算术运算（整数加减运算）
   
    1. 前/后置自家/自减：p++,--p

   2. 自反算术运算：p+=1,p-=10（若p地址为2000，p+i跳过i个整形数据指向它下一个单元（即p+i=2000i1*4）（按目标字节的长度移动i个）
   
    p+=10（p改变了），p+10(p没改变），两者不等价
   
    Int a[5],*p=a，i；
   
    *p++(先取*p(a0)，再向后跳一个(a1)），*（++p）（先跳一个至a1，再取a1的地址）
   
    表示指针在内存一定范围内的上下移动

     3.整数加减运算：p+1,p-1


####1. 指针的比较运算(比较的两个指针p1,p2必须指向同一数组）

`>  >=  <  <=  ==  !=`，结果为1(真)或0(假)

int arr[10];

int *p1=&arr[3];

int *p1=&arr[3];

p1>p2//结果为true(非零）

![](https://pic.imgdb.cn/item/676e9ed8d0e0a243d4ebc207.png)

####题目内容：

已知 f1(int) 是类 A 的公有成员函数，p 是指向成员函数 f1() 的指针，采用（）是正确的。

A. p = f1

B. p = A::f1

C. p = A::f1()

D. p = f1()

解析：
在C++ 中，当我们要将一个指针指向类的成员函数时，正确的语法是使用类名和作用域解析运算符 ::，并且不需要加括号。括号用于调用函数，而这里是赋值指针，不需要调用函数。

正确答案是：B. p = A::f1//错误答案：C，若p=A::f1()表示p是f1的返回值


####例题2


这是一道关于C++指针定义的选择题。

题目内容：

下列定义中，（）是定义指向数组的指针p。

选项有：


A. int p[5]

B. int (p)[5]

C. (int)p[5]

D. int *p[]

解析：

• 选项A：int p[5]定义的是一个包含5个整数的数组。

• 选项B：int (*p)[5]正确地定义了一个指向包含5个整数的数组的指针。这里(*p)表示p是一个指针，[5]表示它指向的是一个包含5个元素的数组。

• 选项C：(int*)p[5]这种写法是错误的。它可能会被误解为定义一个包含5个指向整数的指针的数组，但语法不正确。

• 选项D：int *p[]定义的是一个指针数组，即一个数组，其元素是指向整数的指针。

正确答案是：B. int (*p)[5]



####例题3
16、对于int *Pa[5]的描述，（）是正确的

A.pa 是一个指向数组的指针，所指向的数组是5个int型元素

B.pa 是一个指某数组中第5个元素的指针，该该元索是int型变量

C.pa[5]表示某数组的第5个元素的值

D.pa 是一个具有5个元素的指针数组，每个元素是一个int 型指针

误A，正确：D

####解析
1. A选项对应的形式：

• 如果pa是一个指向数组的指针，所指向的数组是5个int型元素，声明形式应该是int (*pa)[5];。

• 这里pa是一个指针，指向一个包含5个int型元素的数组。

2. B选项对应的形式：

• 如果pa是一个指向某数组中第5个元素的指针，该元素是int型变量，假设数组名为arr，声明形式应该是int *pa = &arr[4];（假设数组下标从0开始，第5个元素下标是4）。

• 这里pa是一个指针，指向arr数组中的第5个元素。

3. C选项对应的形式：

• 如果pa[5]表示某个数组的第5个元素的值，假设数组名为arr，声明形式应该是int arr[5]; int value = arr[4];（假设数组下标从0开始，第5个元素下标是4）。

• 这里arr是一个包含5个int型元素的数组，value获取了arr数组中的第5个元素的值。


####相关知识点

1. 指向普通变量的指针

• 定义：

• 在C++中，定义一个指向普通整数变量的指针如下：

int num = 10;

int *p = &num;

• 这里int *p表示p是一个指向整数类型的指针，&num获取num变量的地址并赋值给p。

• 使用：

• 可以通过指针来访问和修改所指向变量的值：

*p = 20; // 修改num的值

cout << num << std::endl; // 输出20

2. 指向函数的指针

• 定义：

• 假设有一个函数int add(int a, int b)，定义一个指向该函数的指针如下：

int add(int a, int b) {

    return a + b;

}

int (*p)(int, int) = &add;

• 这里int (*p)(int, int)表示p是一个指向函数的指针，该函数接受两个整数参数并返回一个整数，&add获取add函数的地址并赋值给p。

• 使用：

• 可以通过指针来调用函数：

int result = (*p)(3, 5); // 调用add函数，结果为8

cout << result << std::endl;

3. 指向结构体的指针

• 定义：

• 假设有一个结构体struct Point，定义一个指向该结构体的指针如下：

struct Point {

    int x;
    
    int y;

};

Point pt = {1, 2};

Point *p = &pt;

• 这里Point *p表示p是一个指向Point结构体类型的指针，&pt获取pt结构体变量的地址并赋值给p。

• 使用：

• 可以通过指针来访问结构体的成员：

(*p).x = 3; // 修改pt.x的值为3

p->y = 4; // 另一种修改pt.y的值为4的方式

cout << pt.x << ", " << pt.y << endl; // 输出3, 4

4. 指向数组的指针（本题相关类型）

• 定义：

• 假设有一个二维数组int matrix[3][4]，定义一个指向二维数组的指针如下：

int matrix[3][4] = {
   
    {1, 2, 3, 4},
  
    {5, 6, 7, 8},
   
    {9, 10, 11, 12}

};

int (*p)[4] = matrix;

• 这里int (*p)[4]表示p是一个指向包含4个整数的数组的指针，matrix本身是一个二维数组，在这种情况下可以直接将matrix赋值给p，因为二维数组名在很多情况下会退化为指向其首元素（这里是包含4个整数的一维数组）的指针。

• 使用：

• 可以通过指针来访问数组元素：

cout << (*p)[0] << endl; // 输出1，即matrix[0][0]

p++;

cout << (*p)[1] << endl; // 输出6，即matrix[1][1]
