# Clauis
### 指针的 `const` 修饰

`const` 可以修饰数据类型，也可以修饰指针变量。

#### 常量指针（修饰数据类型）

`const` 修饰数据类型时，指针指向的地址可以改变，但指针指向的地址所对应的内容不可以改变。

```cpp
int a = 0, b = 0;
const int *p = &a;
*p = 1; // 错误
p = &b; // 正确
```

#### 指针常量（修饰指针变量）

`const` 修饰指针变量时，指针指向的地址不可以改变，但指针指向的地址所对应的内容可以改变。

```cpp
int a = 0, b = 0;
int *const p = &a;
*p = 1; // 正确
p = &b; // 错误
```
![](https://pic.imgdb.cn/item/676e9ed0d0e0a243d4ebc204.png)

### 指针运算：（指针在内存中的移位）

- 赋值运算
- 算术运算
- 比较运算（使指针变量指向某一对象）

1. 赋值运算：

    ![](https://pic.imgdb.cn/item/676e9ed4d0e0a243d4ebc205.png)

1. 指针的算术运算（整数加减运算）
   
    1. 前/后置自家/自减：p++,--p
    2. 自反算术运算：p+=1,p-=10（若p地址为2000，p+i跳过i个整形数据指向它下一个单元（即p+i=2000i1*4）（按目标字节的长度移动i个）
    p+=10（p改变了），p+10(p没改变），两者不等价
    Int a[5],*p=a，i；
    *p++(先取*p(a0)，再向后跳一个(a1)），*（++p）（先跳一个至a1，再取a1的地址）
    表示指针在内存一定范围内的上下移动
    3.整数加减运算：p+1,p-1

1. 指针的比较运算(比较的两个指针p1,p2必须指向同一数组）
`>  >=  <  <=  ==  !=`，结果为1(真)或0(假)
int arr[10];
int *p1=&arr[3];
int *p1=&arr[3];
p1>p2//结果为true(非零）

![](https://pic.imgdb.cn/item/676e9ed8d0e0a243d4ebc207.png)

题目内容：
已知 f1(int) 是类 A 的公有成员函数，p 是指向成员函数 f1() 的指针，采用（）是正确的。
A. p = f1
B. p = A::f1
C. p = A::f1()
D. p = f1()

解析：
在C++ 中，当我们要将一个指针指向类的成员函数时，正确的语法是使用类名和作用域解析运算符 ::，并且不需要加括号。括号用于调用函数，而这里是赋值指针，不需要调用函数。

正确答案是：B. p = A::f1//错误答案：C
